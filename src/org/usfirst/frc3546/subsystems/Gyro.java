// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc3546.subsystems;

import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.PIDSource;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.SPI;
import org.usfirst.frc3546.Robot;
import org.usfirst.frc3546.RobotMap;
import org.usfirst.frc3546.commands.*;
import com.kauailabs.navx.frc.AHRS;

import edu.wpi.first.wpilibj.command.Subsystem;

import java.sql.Driver;


/**
 *
 */
public class Gyro extends Subsystem {

    private AHRS gyro_board;

    private float initial_offset = 0;

    public static final boolean AUTO_CORRECT_GYRO_BASED_ON_INIT_COMPASS = false;
    public static final float LEVEL_TOLERANCE = 7; //Degrees

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS


    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public Gyro (){
        try {
            /* Communicate w/navX MXP via the MXP SPI Bus.                                     */
            /* Alternatively:  I2C.Port.kMXP, SerialPort.Port.kMXP or SerialPort.Port.kUSB     */
            /* See http://navx-mxp.kauailabs.com/guidance/selecting-an-interface/ for details. */
            gyro_board = new AHRS(SPI.Port.kMXP);
            gyro_board.zeroYaw();

            if (AUTO_CORRECT_GYRO_BASED_ON_INIT_COMPASS){
                if (!gyro_board.isMagneticDisturbance()) {
                    initial_offset = -getCompassCorrectedForAlliance();
                }
            }

        } catch (RuntimeException ex ) {
            DriverStation.reportError("Error instantiating navX MXP:  " + ex.getMessage(), true);
        }
    }

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    /**
     * Get the current orientation of the robot relative to it's starting orientation
     * @return An angle from -180 to 180 that represents the angle between the robot's orientation vector and the
     * vector from the center of the field to the midpoint of the opposing alliance wall
     * If not connected to the field, we'll assume that we're on red
     *
     * The compass should be calibrated so that the vector from the center of the field to the midpoint of the blue
     * alliance wall is the zero heading
     */
    public float getRobotAngle() {
        //There are a couple options here, they are as follows:
        // - gyro_board.getYaw() (Proccesed gyro data)
        // - gyro_board.getCompassHeading() (Proccessed compass data)
        // - gyro_board.getFusedHeading() (Combined compass and gyro data)

        float board_angle;
        if (gyro_board.isMagneticDisturbance()){
            board_angle = getGyroSensorAngle();
        } else {
            board_angle = getCompassCorrectedForAlliance();
        }

        return board_angle;
    }

    public float getCompassCorrectedForAlliance(){
        DriverStation.Alliance alliance = DriverStation.getInstance().getAlliance();

        int compass_offset;
        if (alliance.equals(DriverStation.Alliance.Red)){
            compass_offset = 0;
        } else if (alliance.equals(DriverStation.Alliance.Blue)) {
            compass_offset = 180;
        } else {
            compass_offset = 0;
        }

        float board_angle = gyro_board.getFusedHeading();
        board_angle = (board_angle + compass_offset) % 360;
        if (board_angle > 180){
            //Shift from 0..360 to -180..180 system
            board_angle = board_angle - 360;
        }

        return board_angle;
    }

    public float getGyroSensorAngle(){
        return gyro_board.getYaw() + initial_offset;
    }

    public double getRobotPitch(){
        return gyro_board.getRoll();
    }

    public double getRobotRoll(){
        return gyro_board.getPitch();
    }

    /**
     * Makes a judgement about whether or not the robot is level relative to the field. Probably used to
     * check that we're over a defense
     * @return True if the robot is level relative to the field. False otherwise
     */
    public boolean isLevel(){
        return Math.abs(gyro_board.getPitch()) < LEVEL_TOLERANCE && Math.abs(gyro_board.getRoll()) < LEVEL_TOLERANCE;
    }

    public PIDSource getRobotAnglePIDSource(){
        gyro_board.setPIDSourceType(PIDSourceType.kDisplacement);
        return gyro_board;
    }
}

